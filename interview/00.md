1. **线程与进程的区别？**

2. 如何实现线程安全？

3. 什么是死锁？如何避免死锁？

4. 什么是线程池？如何使用？

5. 什么是并发、并行和异步的区别？

6. Go 中的并发模型（Goroutine 和 Channel）？

7. 什么是上下文切换？如何减少上下文切换？

8. 介绍一下Go语言中的内存对齐，

   1. 什么是内存对齐？

      - 内存对齐指的是数据在内存中的存储地址必须是其大小的倍数。
      - 例如，4 字节的 `int32` 类型通常会要求其地址是 4 的倍数。
      - 内存对齐的目的是提升 CPU 访问数据的效率，因为 CPU 从内存读取数据时是按块读取的。

   2. Go 语言中的内存对齐规则是什么？

      - Go 语言中，结构体中的每个字段都要按其类型大小进行对齐。

      - 每个字段的起始地址应该是该字段类型大小的倍数。

      - Go 会根据字段类型的大小，插入必要的填充字节（Padding），确保对齐。

   3. 什么是结构体内存对齐？

      - 结构体中的字段会根据其类型大小进行对齐，以确保每个字段在内存中的地址是对齐的。

      - 这可能导致内存浪费，因为会插入填充字节来满足对齐要求。

      - 例如：

        ```go
        type Example struct {
            A int8  // 1字节
            B int64 // 8字节
            C int32 // 4字节
        }
        ```

        在这个结构体中，

        ```
        A
        ```

         后面会有 7 字节的填充，以保证 

        ```
        B
        ```

         的地址是 8 的倍数。

   4. 如何减少结构体的内存对齐填充？

      - 通过调整结构体字段的顺序，可以减少内存填充的浪费。
      - 把较大的字段放在前面，较小的字段放在后面，减少空余的填充字节。例如：

      ```
      type Optimized struct {
          B int64 // 8字节
          C int32 // 4字节
          A int8  // 1字节
      }
      ```

      这种排列方式减少了内存浪费。

   5. 如何计算结构体的内存对齐大小？

      - 每个字段对齐的偏移量应该是其类型大小的倍数。

      - 结构体的总大小应该是其最大字段大小的倍数（通常是 8 字节对齐）。

   6. 可以使用 

      ```
      unsafe.Sizeof
      ```

       来计算结构体的实际占用内存：

      ```go
      package main
      
      import (
          "fmt"
          "unsafe"
      )
      
      type Example struct {
          A int8
          B int64
          C int32
      }
      
      func main() {
          fmt.Println(unsafe.Sizeof(Example{})) // 输出 24
      }
      ```

   7. Go 中内存对齐对性能有何影响？

      - 内存对齐有助于提高 CPU 访问内存的效率，因为 CPU 通常以固定大小的块（如 8 字节或 16 字节）读取内存。
      - 如果数据不对齐，CPU 可能需要额外的指令来处理未对齐的数据，导致性能下降。
      - 对齐还可以减少 CPU 缓存行不命中（cache miss）的发生，提高缓存命中率。

   8. 内存对齐是否会浪费内存？如何优化？

      - 内存对齐会带来一定的内存浪费，特别是在字段大小差异较大的结构体中。

      - 通过合理调整字段顺序或使用小巧的字段类型（如 `int16` 或 `int8`）可以减少内存浪费。

      - 但也需要权衡性能和内存利用率，过度优化内存对齐可能会降低代码的可读性和维护性。

   9. 如何通过 `unsafe` 包获取结构体字段的偏移量？

      使用 `unsafe.Offsetof` 可以获取结构体中字段的内存偏移量：

      ```GO
      package main
      
      import (
          "fmt"
          "unsafe"
      )
      
      type Example struct {
          A int8
          B int64
          C int32
      }
      
      func main() {
          e := Example{}
          fmt.Println(unsafe.Offsetof(e.A)) // 输出 0
          fmt.Println(unsafe.Offsetof(e.B)) // 输出 8
          fmt.Println(unsafe.Offsetof(e.C)) // 输出 16
      }
      ```

      这个方法可以帮助了解结构体的内存布局。

      9. 什么是 `unsafe.Alignof`？

         `unsafe.Alignof` 用于获取数据类型的对齐大小。例如：

         ```GO
         fmt.Println(unsafe.Alignof(int64(0))) // 输出 8
         fmt.Println(unsafe.Alignof(int32(0))) // 输出 4
         ```

         

      3. 内存对齐在多平台上是否相同？

      - 内存对齐在不同的硬件平台上可能有所不同，尤其是在 32 位和 64 位架构之间。

      - Go 语言根据不同平台的要求自动调整内存对齐规则，因此开发者通常不需要手动调整对齐，但在性能敏感场景下了解这些差异仍然很重要。

9. GMP 调度模型?
10. 数据库中有哪些锁?
11. 