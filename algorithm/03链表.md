在上篇文章中，我们深入探讨了**[数组](https://mp.weixin.qq.com/s/c-yE-d9Tl_Sg3kd7Cpg3xg)**这一基础数据结构及其特性。***数组以其固定大小和快速访问***的特点被广泛应用，但在某些场景下，其固有的局限性也逐渐显露出来，例如在频繁的插入和删除操作中，数组的效率显得捉襟见肘。为了应对这些挑战，我们引入了链表这一灵活且动态的数据结构。链表通过节点的连接方式，允许我们快速地进行数据的增删操作，是许多算法和数据结构的重要基础。接下来，我们将详细了解链表的基本概念、类型及其应用场景！

## 单链表

相比数组，链表稍微复杂一点。链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过**指针**将一组零散的节点串联在一起。每个节点不仅要存放一个数据元素的值，还要存放下一个节点的地址，该地址被称为**后继指针 next**。

![单链表](assets/Untitled-2023-02-22-0948-5590568.png)

- 链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。

- 尾节点的后继指针 next 指向的不再是下一个节点。而是指向一个空地址 `null`. 这样做的好处是：防止尾节点的后继指针 next 成为一“野”指针，导致遍历链表根本停不下来，或者出现一堆本不属于该链表的垃圾数据等。

  > 在 Java、C++ 和 Python 中分别被记为 `null`、`nullptr` 和 `None`；

我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移节点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。

### 单链表的基本操作

#### 插入操作

向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：

- 插入到链表的头部（头节点之后），作为首元节点；
- 插入到链表中间的某个位置；
- 插入到链表的最末端，作为链表中最后一个数据元素；

虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：

1. 将新节点的 next 指针指向插入位置后的节点；
2. 将插入位置前结点的 next 指针指向插入节点；

比如，我们在链表 `{1,2,3,4}` 的基础上分别实现在头部、中间部位、尾部插入新元素 5，其实现过程如下图：

![image-20240906180517971](assets/image-20240906180517971.png)

从图中可以看出，虽然新元素的插入位置不同，但实现插入操作的方法是一致的，都是**先将新节点的 next 指针指向插入位置后的节点 **(下文用①代指此步骤)，然后才是**将插入位置前节点的 next 指针指向插入节点**(下文用②代指此步骤)。

> Tips:
>
> 链表插入元素的操作必须是先步骤 ①，再步骤 ②；反之，若先执行步骤 ②，除非再添加一个指针，作为插入位置后续链表的头指针，否则会导致插入位置后的这部分链表丢失，无法再实现步骤 ①。

通过上面的图示我们搞明白了基本思路，下面使用 Go 语言来实现链表插入元素的操作：

```go
// 定义链表节点结构
type Node struct {
	Data int
	Next *Node
}

// 向链表中插入元素
func Insert(head *Node, data int, position int) *Node {
	if position < 0 {
		return head
	}
	// 创建临时节点 temp
	temp := head

	// 找到要插入位置的前一个节点
	for i := 1; i < position; i++ {
		if temp == nil {
			fmt.Println("插入位置无效")
			return head
		}
		temp = temp.Next
	}

	// 创建插入节点 c
	newNode := &Node{Data: data}

	// 向链表中插入节点
	if temp != nil {
		newNode.Next = temp.Next
		temp.Next = newNode
	} else {
		// 如果 temp 是 nil，说明要插入在链表末尾
		newNode.Next = nil
		head = newNode
	}

	return head
}
```



我们先来简单介绍一下链表结构的优缺点：

- 优点：
  1. 动态大小：根据数据大小动态增长或缩小
  2. 插入和删除效率高：插入和删除元素只需要改变指针，时间复杂度为 O(1)
  3. 内存利用灵活：不需要连续的内存空间
- 缺点：
  1. 访问速度慢：由于链表是线性存储的，访问特定元素需要从头节点开始遍历，平均时间复杂度为 O(n)
  2. 额外的内存开销：每个节点需要存储指向下一个节点的指针，这会导致额外的内存开销
  3. 不支持随机访问：无法像数组一样通过索引直接访问元素

从上面的优缺点中可以看到链表在动态大小、插入和删除效率方面具有显著优势，但在访问速度和内存开销上存在一定的劣势。这些特性使得链表在不同场景中表现出不同的适用性。

为了更好地利用链表的优势并弥补其不足，除了单链表外，还有循环链表、双向链表、循环双向链表。每种类型都有其特定的结构和应用场景，以满足不同需求。

## 双向链表

单向链表只有一个方向，节点只有一个后继指针 next 指向下一个节点。而双向链表，顾名思义，它支持两个方向，每个节点不止有一个后继指针 next 指向后面的节点，还有一个前驱指针 prev 指向前面的节点。

![双向链表](assets/Untitled-2023-02-22-0948-5591177.png)

从图中也可以看出，在双向链表中，每个节点通常包含以下三个部分：

- **数据域(data)**：存储节点的数据。
- **前驱指针(prev)**：指向链表中前一个节点的指针。
- **后继指针(next)**：指向链表中下一个节点的指针。

双向链表需要额外的两个空间来存储前驱节点和后继节点的地址。因此，存储同样多的数据，双向链表要比单链表占用更多的内存空间（因为有prev、next两个指针），虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。

它的特点就是：

- 从双链表的任意一个节点开始，都可以很方便的访问它的前驱节点和后继节点。
- 头节点的前驱指针和尾节点的后继指针都指向 `Null`。

### 双链表的基本操作

双向链表的基本操作，包括节点的插入、删除、查找以及遍历。我们将通过 Go 和 JavaScript 语言的实现示例，在完整的代码实现之前，先将双向链表的数据结构定义出来：

```go
// 定义双向链表的节点结构体
type Node struct {
	Data int
	prev *Node // 指向前一个节点
	next *Node // 指向后一个节点
}

// 定义双向链表结构体
type DoublyLinkedList struct {
	head *Node // 指向链表头部
	tail *Node // 指向链表尾部
}
```

这两段代码定义了双向链表的基本结构，其中 `Node` 结构体用于表示链表中的单个节点，而 `DoublyLinkedList` 结构体则用于表示整个链表。

#### **创建节点**

创建一个新的节点，包含数据域、前驱指针和后继指针。

```go
// 创建一个新的节点
func newNode(data int) *Node {
	return &Node{Data: data}
}
```

这个 `newNode` 函数的作用是创建一个新的双向链表节点，并将传入的数据存储在节点的 `Data` 字段中。函数返回一个指向新创建的 `Node` 结构体的指针，这个指针可以用于将新节点插入到双向链表中。比如调用 `newNode(10)` 时，它会创建一个新的节点，其中 `Data` 字段的值为 `10`，并且返回一个指向这个新节点的指针。

#### **插入新节点**

在双向链表中插入新节点根据添加位置不同，可分为以下 3 种情况：

- 插入到链表的头部（头节点之后），作为首元节点；
- 插入到链表中间的某个位置；
- 插入到链表的最末端，作为链表中最后一个数据元素；

- 末尾插入

  ```go
  // 在双向链表的末尾插入一个新节点
  func (dll *DoublyLinkedList) append(data int) {
  	newNode := newNode(data)
  	if dll.tail == nil {
  		dll.head = newNode
  		dll.tail = newNode
  		return
  	}
  	dll.tail.next = newNode
  	newNode.prev = dll.tail
  	dll.tail = newNode
  }
  ```

  

- 指定位置插入

  ```go
  // 在双向链表的指定位置插入一个新节点
  func (dll *DoublyLinkedList) insertAt(data int, position int) {
      if position < 0 {
          // 负数位置无效
          return
      }
  
      newNode := newNode(data) // 创建新节点
      if dll.head == nil {
          // 如果链表为空，新节点成为唯一的节点
          dll.head = newNode
          dll.tail = newNode
          return
      }
  
      current := dll.head
      for current != nil && position > 0 {
          // 移动到指定位置
          current = current.next
          position--
      }
  
      if current == nil {
          // 插入位置超出链表长度，将新节点插入到末尾
          dll.tail.next = newNode
          newNode.prev = dll.tail
          dll.tail = newNode
      } else {
          // 插入新节点到链表中
          newNode.next = current
          newNode.prev = current.prev
          if current.prev != nil {
              current.prev.next = newNode
          }
          current.prev = newNode
      }
  }
  ```

  

#### **删除节点**

从链表中删除一个数据无外乎这两种情况：

- 删除节点中“值等于某个给定值”的节点；这就意味着需要先定位被删除元素，然后再执行删除操作，平均时间复杂度为O(n)。
- 删除给定指针指向的节点。 这就意味着不用去定位被删除元素。直接删除这个指针指向的元素即可，时间复杂度为O(1)。

```go
func (dll *DoublyLinkedList) remove(node *Node) {
	if node == nil {
		return
	}
	if node.prev != nil {
		node.prev.next = node.next
	} else {
		dll.head = node.next // 删除头节点
	}
	if node.next != nil {
		node.next.prev = node.prev
	} else {
		dll.tail = node.prev // 删除尾节点
	}
}
```

