在上篇文章中，我们深入探讨了**[数组](https://mp.weixin.qq.com/s/c-yE-d9Tl_Sg3kd7Cpg3xg)** 这一基础数据结构及其特性。***数组以其固定大小和快速访问***的特点被广泛应用，但在某些场景下，其固有的局限性也逐渐显露出来，例如在频繁的插入和删除操作中，数组的效率显得捉襟见肘。为了应对这些挑战，我们引入了链表这一灵活且动态的数据结构。链表通过节点的连接方式，允许我们快速地进行数据的增删操作，是许多算法和数据结构的重要基础。接下来，我们将详细了解链表的基本概念、类型及其应用场景！

## 概念
**循环链表是一种特殊的单链表，它跟单链表唯一的区别就在于尾节点**。在单链表中，尾节点指针指向空地址，表示这就是最后的节点了。而**循环链表的尾结点指针是指向链表的头节点或者其他节点；循环链表的节点数不限，但必须至少有一个头节点**。在循环链表中插入或删除节点时，需要特别处理，不能破坏原有的环形结构。遍历循环链表时也需要使用特殊的方法，否则可能会陷入死循环。循环链表如下图：

<img src="assets/image-20240923153905577.png" style="max-width:600px" />

> Tips：
>
> 虽然循环链表成环状，但本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等。循环链表和普通链表相比，唯一的不同就是循环链表首尾相连，其他都完全一样。

和单链表相比，循环链表的优点是**从链尾到链头比较方便**。**当要处理的数据具有环型结构特点时，就特别适合采用循环链表**。比如著名的[约瑟夫](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)问题；这个问题后面我们来解一下。

## 循环链表的基本操作

先定义基本结构

```go
type Node struct {
	data int
	next *Node
}

type CircularLinkedList struct {
	head *Node
}

//  打印循环链表中的所有节点
func (cll *CircularLinkedList) Print() {
	if cll.head == nil {
		fmt.Println("List is empty")
		return
	}
	current := cll.head
	for {
		fmt.Print(current.data, " -> ")
		current = current.next
		if current == cll.head {
			break
		}
	}
	fmt.Println("(back to head)")
}
```

### 插入节点

实现插入节点的方法时，需要考虑以下几种情况：

- **链表为空**：如果 `head` 为 `nil`，则说明链表为空。就要创建一个新节点，并将其 `next` 指向自身，设置 `head` 为新节点。
- **链表非空**：如果链表不为空，遍历链表找到最后一个节点（即 `next` 指针指向头节点的节点）。将新节点插入在最后节点之后，并将新节点的 `next` 指向 `head`，形成循环。

代码实现：

```go
// 在循环链表的末尾插入新节点
func (cll *CircularLinkedList) Insert(data int) {
	newNode := &Node{data: data}
	if cll.head == nil {
		cll.head = newNode
		newNode.next = cll.head
	} else {
		current := cll.head
		for current.next != cll.head {
			current = current.next
		}
		current.next = newNode
		newNode.next = cll.head
	}
}
```

复杂度分析:

- **时间复杂度**：`O(n)`
- **空间复杂度**：`O(1)`

### 删除节点

实现删除节点的方法时，需要考虑以下几种情况：

- **链表为空**：为空则直接退出。
- **链表非空**：遍历找出节点
  - 如果是头节点：
    - 只有一个节点，直接将 head 设置为 `NULL。`
    - 多个节点，找到最后一个节点，并将其更新前一个节点的 next 指针，跳过要删除的节点。
  - 非头节点
    - 直接将要删除节点的前一个节点的 next 指针指向要删除节点的下一个节点（也就是跳过要删除的节点）
  - 找不到：打印提示信息

代码实现：

```go
func (cll *CircularLinkedList) Delete(data int) error {
	if cll.head == nil {
		return errors.New("list is empty")
	}

	// 如果是头节点
	if cll.head.data == data {
		if cll.head.next == cll.head {
			// 只有一个节点
			cll.head = nil
		} else {
			// 多个节点
			current := cll.head
			for current.next != cll.head {
				current = current.next
			}
			current.next = cll.head.next
			cll.head = cll.head.next
		}
		return nil
	}

	// 非头节点
	current := cll.head
	for current.next != cll.head {
		if current.next.data == data {
			current.next = current.next.next
			return nil
		}
		current = current.next
	}

	return errors.New("data not found")
}
```

复杂度分析：

- 时间复杂度：O(n)
- 空间复杂度：O(1)



## 实践

我们来看看文章开头说的约瑟夫问题，约瑟夫问题是一个古老的数学问题，据说起源于公元1世纪。这个问题的故事情境是：在一个围成圆圈的人群中，依次数到某个数就将该人杀死，直到只剩下最后一个人。

> 解读一下：
>
> 假设有 n 个人围成一圈，从第 k 个人开始依次报数，报到 m 的人出局（kill）。然后从下一个人重新开始报数，报到 m 的人再次出局；重复这个过程，直到只剩下一个人。

































