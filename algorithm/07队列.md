大家好，我是长林啊！一个爱好 JavaScript、Go、Rust 的全栈开发者；致力于终身学习和技术分享。

在上篇文章中，我们深入探讨了堆栈这一基础数据结构的相关概念及基本操作。我们继续看看队列！

## 栈的基本概念

在数据结构与算法中，**队列**（Queue）是一种**「先进先出」**（FIFO, First In First Out）的线性数据结构。这意味着第一个进入队列的元素会第一个被取出，类似于排队买票或等车的场景。

我们把队列中允许插入的一端称为 **「队尾（rear）」**；把允许删除的另一端称为 **「队头（front）」**。当表中没有任何数据元素时，称之为 **「空队」**。

![queue](./assets/queue.png)

队列跟栈一样,也是首先的线性表数据结构；队列有两种基本操作：**「插入操作」** 和 **「删除操作」**。

- 队列的插入操作又称为「入队」。
- 队列的删除操作又称为「出队」。

### 特性
队列的特性主要体现在其操作方式和处理规则上。作为一种**先进先出**（FIFO, First In First Out）的数据结构，队列的特性可以总结为以下几个方面：

- 先进先出原则：即第一个进入队列的元素总是第一个被取出。
- 有序性：队列中的元素按照插入的顺序保持有序。每个新元素总是被插入到队列的尾部，而从队列中移除的元素始终来自队列的头部。
- 容量限制：在固定大小（有界）的队列中，队列可能有容量限制。如果队列达到最大容量，再插入新元素时将触发**队满**状态。
- 空间与时间复杂度：队列操作的时间复杂度一般为 `O(1)`，因为插入和删除操作仅涉及头部和尾部的调整，不需要遍历整个队列。队列的空间复杂度取决于队列中存储的元素数量。

## 队列的实现

与栈一样，队列既可以用数组来实现，也可以用链表来实现。
- 用数组实现的队列叫作顺序队列。
- 用链表实现的队列叫作链式队列。



### 基于数组的实现

在实现之前，我们先理清思路：
1. 数组定义 

   使用一个固定大小的数组来存储队列中的元素，并定义两个指针变量 `front` 和 `rear`，分别表示队列的头部和尾部位置。`front` 指向队列中的第一个元素，`rear` 指向队列中最后一个元素的位置。

2. 初始化

   - 创建一个大小为 `capacity` 的数组 `queue[]` 来存储队列元素。

   - 初始化 `front` 和 `rear` 指针，通常设置为 `-1` 或 `0`。也可以将 `front` 初始化为 `0`，将 `rear` 初始化为 `-1`，以方便后续处理。

   - 初始化队列大小 `size` 为 `0`，用于记录队列中当前的元素个数。

3. 入队操作（Enqueue）

   - 检查是否满：在入队之前，需要检查队列是否已满。队列满的条件是 `size == capacity`。

   - 更新 `rear`：如果队列未满，将 `rear` 指针向前移动（即 `rear = (rear + 1) % capacity`），以便环形利用数组。当 `rear` 指向数组末尾时，下一次入队会回到数组的起点。

   - 插入元素：在 `rear` 所指的位置插入新元素。

   - 更新 `size`：入队成功后，`size` 增加 1。

4. 出队操作（Dequeue）

   - 检查是否空：在出队之前，需要检查队列是否为空。队列空的条件是 `size == 0`。

   - 获取队头元素：取出 `front` 所指位置的元素。

   - 更新 `front`：将 `front` 指针向后移动（即 `front = (front + 1) % capacity`）。当 `front` 到达数组末尾时，下一次出队会从数组起点开始。

   - 更新 `size`：出队成功后，`size` 减少 1。

5. 队列满与空的判断

   - 队列满的条件：`size == capacity`。

   - 队列空的条件：`size == 0`。

#### Go 语言的实现
```go
package queue

type ArrayQueue[T any] struct {
	data     []T
	capacity int // 队列容量
	front    int // 队头指针
	rear     int // 队尾指针
	size     int // 队列长度
}

type ArrayQueueMethod[T any] interface {
	Enqueue(T)
	Dequeue() (T, bool)
	Front() T
	IsEmpty() bool
	IsFull() bool
	Size() int
}

func NewArrayQueue[T any](capacity int) *ArrayQueue[T] {
	return &ArrayQueue[T]{
		data:     make([]T, capacity),
		capacity: capacity,
		front:    0,
		rear:     -1,
		size:     0,
	}
}

var _ ArrayQueueMethod[int] = (*ArrayQueue[int])(nil)

// 入队
func (aq *ArrayQueue[T]) Enqueue(data T) {
	// 判断队列是否已满
	if aq.IsFull() {
		return
	}
	aq.rear = (aq.rear + 1) % aq.capacity
	aq.data[aq.rear] = data
	aq.size++
}

// 出队
func (aq *ArrayQueue[T]) Dequeue() (T, bool) {
	// 判断队列是否为空
	if aq.IsEmpty() {
		var zero T
		return zero, false
	}
	// 队头元素出队
	item := aq.data[aq.front]
	// 更新对头
	aq.front = (aq.front + 1) % aq.capacity
	aq.size--
	return item, true
}

// 队头
func (aq *ArrayQueue[T]) Front() T {
	if aq.IsEmpty() {
		var zero T
		return zero
	}
	return aq.data[aq.front]
}

// 判断队列是否为空
func (aq *ArrayQueue[T]) IsEmpty() bool {
	return aq.size == 0
}

// 判断队列是否已满
func (aq *ArrayQueue[T]) IsFull() bool {
	return aq.size == aq.capacity
}

// 队列长度
func (aq *ArrayQueue[T]) Size() int {
	return aq.size
}
```

Go 语言的完整代码和测试用例可以查看 https://go.dev/play/p/e7Izks-uiTp](https://go.dev/play/p/e7Izks-uiTp)。

#### TypeScript 的实现

```ts
// /stack/arraystack.ts
export default class ArrayStack<T> {
    private data: T[];
    private count: number;

    constructor() {
        this.data = [];
        this.count = -1;
    }

    push(item: T) {
        this.data.push(item);
        this.count++;
    }

    pop(): T | undefined {
        if (this.count < 0) {
            return undefined;
        }
        const value = this.data.pop();
        this.count--;
        return value;
    }

    top(): T | undefined {
        if (this.count < 0) {
            return undefined;
        }
        return this.data[this.count];
    }

    isEmpty(): boolean {
        return this.count < 0;
    }

    size(): number {
        return this.count + 1;
    }

    clear() {
        this.data = [];
        this.count = -1;
    }

    print() {
        console.log(this.data);
    }
}
```
测试用例：
```ts
// /stack/arraystack.test.ts
import ArrayStack from './arraystack'; // 确保路径正确

describe('ArrayStack', () => {
    let stack: ArrayStack<number>;

    beforeEach(() => {
        stack = new ArrayStack<number>();
    });

    test('should initialize empty stack', () => {
        expect(stack.isEmpty()).toBe(true);
        expect(stack.size()).toBe(0);
    });

    test('should push items onto the stack', () => {
        stack.push(1);
        stack.push(2);
        stack.push(3);

        expect(stack.isEmpty()).toBe(false);
        expect(stack.size()).toBe(3);
        expect(stack.top()).toBe(3);
    });

    test('should pop items from the stack', () => {
        stack.push(1);
        stack.push(2);
        stack.push(3);

        expect(stack.pop()).toBe(3);
        expect(stack.size()).toBe(2);
        expect(stack.top()).toBe(2);
    });

    test('should return undefined when popping from an empty stack', () => {
        expect(stack.pop()).toBeUndefined();
    });

    test('should return the top item without removing it', () => {
        stack.push(1);
        stack.push(2);

        expect(stack.top()).toBe(2);
        expect(stack.size()).toBe(2); // Size should remain the same
    });

    test('should clear the stack', () => {
        stack.push(1);
        stack.push(2);
        stack.clear();

        expect(stack.isEmpty()).toBe(true);
        expect(stack.size()).toBe(0);
        expect(stack.top()).toBeUndefined();
    });

    test('should handle multiple push and pop operations', () => {
        stack.push(1);
        stack.push(2);
        stack.push(3);

        expect(stack.pop()).toBe(3);
        expect(stack.pop()).toBe(2);
        expect(stack.pop()).toBe(1);
        expect(stack.isEmpty()).toBe(true);
    });
});
```

### 基于链表的实现
上面看完了基于链表的实现跟数组的方式实现，本质上没有多少不同，只是在数据结构上稍有差异！也是定义一个链表节点结构体，以及一个栈结构体，包含基本的栈操作，如入栈、出栈、查看栈顶元素、检查是否为空和打印栈的内容。

#### Go 语言的实现
```go
// /stack/linkedliststack.go
package stack

import "fmt"

// Comparable 接口用于比较泛型类型
type Comparable[T any] interface {
	Compare(other T) bool
}

// 定义链表节点，T 为类型参数
type Node[T any] struct {
	data T        // 数据域
	next *Node[T] // 指向下一个节点
}

// 定义链表结构，T 为类型参数
type LinkedListStack[T Comparable[T]] struct {
	head   *Node[T] // 头节点
	length uint     // 链表长度
}

// 用于获取类型 T 的零值
func zeroValue[T any]() T {
	var zero T
	return zero
}

// 创建新节点
func NewListNode[T Comparable[T]](v T) *Node[T] {
	return &Node[T]{
		data: v,
		next: nil,
	}
}

// 创建新链表
func NewLinkedListStack[T Comparable[T]]() *LinkedListStack[T] {
	return &LinkedListStack[T]{
		head:   NewListNode[T](zeroValue[T]()),
		length: 0,
	}
}

// 判断链表是否为空
func (list *LinkedListStack[T]) IsEmpty() bool {
	return list.length == 0
}

// 链表入栈
func (list *LinkedListStack[T]) Push(v T) {
	list.head = &Node[T]{
		data: v,
		next: list.head,
	}
	list.length++
}

// 链表出栈
func (list *LinkedListStack[T]) Pop() (data T, ok bool) {
	if list.IsEmpty() {
		return zeroValue[T](), false
	}
	current := list.head
	// 获取链表头部的下一个节点
	list.head = current.next
	list.length--
	return current.data, true
}

// 链表栈顶
func (list *LinkedListStack[T]) Top() (data T, ok bool) {
	if list.IsEmpty() {
		return zeroValue[T](), false
	}
	return list.head.data, true
}

// 链表长度
func (list *LinkedListStack[T]) Size() uint {
	return uint(list.length)
}

// 清空
func (list *LinkedListStack[T]) Clear() {
	list.head = NewListNode[T](zeroValue[T]())
	list.length = 0
}

// 打印
func (list *LinkedListStack[T]) Print() {
	current := list.head
	for current != nil {
		fmt.Print(current.data, " -> ")
		current = current.next
	}
	fmt.Println("nil")
}
```
测试用例如下：
```go
// /stack/linkedliststack_test.go
package stack

import (
	"fmt"
	"testing"
)

// 定义一个简单的类型，实现 Comparable 接口
type Int int

func (a Int) Compare(other Int) bool {
	return a == other
}

func TestLinkedListStack(t *testing.T) {
	stack := NewLinkedListStack[Int]()

	// 测试初始状态
	if !stack.IsEmpty() {
		t.Errorf("Expected stack to be empty")
	}
	if size := stack.Size(); size != 0 {
		t.Errorf("Expected size to be 0, got %d", size)
	}

	// 测试入栈
	stack.Push(1)
	stack.Push(2)
	stack.Push(3)

	// 测试栈的状态
	if stack.IsEmpty() {
		t.Errorf("Expected stack to not be empty")
	}
	if size := stack.Size(); size != 3 {
		t.Errorf("Expected size to be 3, got %d", size)
	}

	// 测试栈顶元素
	if top, ok := stack.Top(); !ok || top != 3 {
		t.Errorf("Expected top element to be 3, got %d", top)
	}

	// 测试出栈
	if popped, ok := stack.Pop(); !ok || popped != 3 {
		t.Errorf("Expected popped element to be 3, got %d", popped)
	}
	if size := stack.Size(); size != 2 {
		t.Errorf("Expected size to be 2 after pop, got %d", size)
	}

	// 测试再次出栈
	if popped, ok := stack.Pop(); !ok || popped != 2 {
		t.Errorf("Expected popped element to be 2, got %d", popped)
	}

	// 测试栈顶元素
	if top, ok := stack.Top(); !ok || top != 1 {
		t.Errorf("Expected top element to be 1, got %d", top)
	}

	// 测试清空栈
	stack.Clear()
	if !stack.IsEmpty() {
		t.Errorf("Expected stack to be empty after clear")
	}
	if size := stack.Size(); size != 0 {
		t.Errorf("Expected size to be 0 after clear, got %d", size)
	}

	// 测试从空栈出栈
	if popped, ok := stack.Pop(); ok || popped != 0 {
		t.Errorf("Expected popped element from empty stack to be 0 and ok to be false, got %d", popped)
	}

	// 测试栈的打印（可选）
	fmt.Println("Current stack state:")
	stack.Print()
}
```
完整代码可以在 [https://go.dev/play/p/mIp8M2BWX5Y](https://go.dev/play/p/mIp8M2BWX5Y) 中体验并查看！

#### TypeScript 的实现
```ts
// /stack/linkedliststack.ts
class LinkedNode<T> {
    data: T
    next: LinkedNode<T> | null
    constructor(v: T, next: LinkedNode<T> | null) {
        this.data = v
        this.next = next
    }
}

interface LinkedListStack<T> {
    push(v: T): void
    pop(): T | null
    top(): T | null
    isEmpty(): boolean
    size(): number
    clear(): void
    print(): void
}

class LinkedListStack<T> implements LinkedListStack<T> {
    private head: LinkedNode<T> | null;
    private length: number;

    constructor() {
        // 初始化
        this.head = null;
        this.length = 0;
    }

    // 入栈
    push(v: T): void {
        const node = new LinkedNode(v, this.head);
        this.head = node;
        this.length++;
    }

    // 出栈
    pop(): T | null {
        if (this.isEmpty()) {
            return null;
        }
        const value = this.head?.data || null;
        this.head = this.head?.next || null;
        this.length--;
        return value;
    }

    // 获取栈顶元素
    top(): T | null {
        if (this.isEmpty()) {
            return null;
        }
        return this.head?.data || null;
    }

    // 判断栈是否为空
    isEmpty(): boolean {
        return this.length === 0;
    }

    // 获取栈长度
    size(): number {
        return this.length;
    }

    // 清空栈
    clear() {
        this.head = null;
        this.length = 0;
    }

    // 打印栈
    print() {
        let current = this.head;
        while (current) {
            console.log(current.data);
            current = current.next;
        }
    }
}

export default LinkedListStack
```
测试用例：
```ts
// /stack/linkedliststack.test.ts
import LinkedListStack from './linkedliststack';

// 定义一个简单的类型用于测试
type TestDataType = number;

describe('LinkedListStack', () => {
    let stack: LinkedListStack<TestDataType>;

    beforeEach(() => {
        stack = new LinkedListStack<TestDataType>();
    });

    test('should be empty on initialization', () => {
        expect(stack.isEmpty()).toBe(true);
        expect(stack.size()).toBe(0);
    });

    test('should push elements onto the stack', () => {
        stack.push(1);
        stack.push(2);
        stack.push(3);

        expect(stack.isEmpty()).toBe(false);
        expect(stack.size()).toBe(3);
        expect(stack.top()).toBe(3);
    });

    test('should pop elements from the stack', () => {
        stack.push(1);
        stack.push(2);
        stack.push(3);

        expect(stack.pop()).toBe(3);
        expect(stack.size()).toBe(2);
        expect(stack.top()).toBe(2);
    });

    test('should return null when popping from an empty stack', () => {
        expect(stack.pop()).toBeNull();
    });

    test('should return the top element without removing it', () => {
        stack.push(1);
        expect(stack.top()).toBe(1);
        expect(stack.size()).toBe(1);
    });

    test('should clear the stack', () => {
        stack.push(1);
        stack.push(2);
        stack.clear();

        expect(stack.isEmpty()).toBe(true);
        expect(stack.size()).toBe(0);
    });

    test('should print the stack elements', () => {
        const consoleSpy = jest.spyOn(console, 'log');
        stack.push(1);
        stack.push(2);
        stack.push(3);

        stack.print();

        expect(consoleSpy).toHaveBeenCalledWith(3);
        expect(consoleSpy).toHaveBeenCalledWith(2);
        expect(consoleSpy).toHaveBeenCalledWith(1);

        consoleSpy.mockRestore(); // 清理 spy
    });
});
```

## 实践应用

### 浏览器的前进后退功能
使用栈实现浏览器的前进和后退功能是一个经典的应用场景。我们可以使用两个栈来保存浏览历史：
- **一个栈用于保存后退历史**。
- **一个栈用于保存前进历史**。

#### 实现思路
- **后退栈**：存储用户已访问的页面，以便在用户选择后退时恢复到之前的页面。
- **前进栈**：存储用户后退后可以前进的页面，以便在用户选择前进时恢复这些页面。

#### 基于链表来实现

- **使用 Go 语言的实现**
```go
package main

import (
	"fmt"
)

// Node 表示双向链表中的一个节点
type Node struct {
	URL  string // 当前 URL
	Prev *Node  // 指向前一个节点
	Next *Node  // 指向下一个节点
}

// BrowserHistory 表示浏览器历史
type BrowserHistory struct {
	Current *Node // 当前节点
}

// History 接口定义浏览器历史的行为
type History interface {
	Visit(url string)
	Back() string
	Forward() string
	CurrentURL() string
}

// 确保 BrowserHistory 实现了 History 接口
var _ History = (*BrowserHistory)(nil)

// NewBrowserHistory 初始化一个新的 BrowserHistory
func NewBrowserHistory() *BrowserHistory {
	return &BrowserHistory{}
}

// Visit 添加一个新的 URL 到历史中
func (b *BrowserHistory) Visit(url string) {
	newNode := &Node{URL: url}
	if b.Current != nil {
		newNode.Prev = b.Current
		b.Current.Next = newNode
	}
	b.Current = newNode
}

// Back 后退到历史中的前一个 URL
func (b *BrowserHistory) Back() string {
	if b.Current == nil || b.Current.Prev == nil {
		return "没有之前的 URL"
	}
	b.Current = b.Current.Prev
	return b.Current.URL
}

// Forward 前进到历史中的下一个 URL
func (b *BrowserHistory) Forward() string {
	if b.Current == nil || b.Current.Next == nil {
		return "没有下一个 URL"
	}
	b.Current = b.Current.Next
	return b.Current.URL
}

// CurrentURL 返回当前的 URL
func (b *BrowserHistory) CurrentURL() string {
	if b.Current == nil {
		return "没有当前 URL"
	}
	return b.Current.URL
}

func main() {
	history := NewBrowserHistory()

	history.Visit("https://www.google.com")
	history.Visit("https://www.facebook.com")
	history.Visit("https://www.twitter.com")

	fmt.Println("当前 URL:", history.CurrentURL()) // Twitter

	fmt.Println("后退到:", history.Back()) // Facebook
	fmt.Println("后退到:", history.Back()) // Google
	fmt.Println("后退到:", history.Back()) // 没有之前的 URL

	fmt.Println("前进到:", history.Forward()) // Facebook
	fmt.Println("前进到:", history.Forward()) // Twitter
	fmt.Println("前进到:", history.Forward()) // 没有下一个 URL
}
```
- **使用 TypeScript 的实现**
```ts
// 定义 IBrowserHistory 接口
interface IBrowserHistory {
    visit(url: string): void;
    back(): string;
    forward(): string;
    currentUrl(): string;
}

// ListNode 类表示双向链表中的一个节点
class ListNode<T> {
    url: string;
    prev: ListNode<T> | null;
    next: ListNode<T> | null;

    constructor(url: string) {
        this.url = url;
        this.prev = null;
        this.next = null;
    }
}

// BrowserHistory 类实现 IBrowserHistory 接口
export default class BrowserHistory implements IBrowserHistory {
    private current: ListNode<string> | null;

    constructor() {
        this.current = null;
    }

    // 访问新 URL
    visit(url: string) {
        const newNode = new ListNode<string>(url);
        if (this.current) {
            newNode.prev = this.current;
            this.current.next = newNode;
        }
        this.current = newNode;
    }

    // 后退到前一个 URL
    back() {
        if (!this.current || !this.current.prev) {
            return "没有之前的 URL";
        }
        this.current = this.current.prev;
        return this.current.url;
    }

    // 前进到下一个 URL
    forward() {
        if (!this.current || !this.current.next) {
            return "没有下一个 URL";
        }
        this.current = this.current.next;
        return this.current.url;
    }

    // 返回当前的 URL
    currentUrl() {
        if (!this.current) {
            return "没有当前 URL";
        }
        return this.current.url;
    }
}
```
测试用例如下：
```ts
// browserHistory.test.ts
import BrowserHistory from './browserlinkedlist'; // 根据实际文件路径修改

describe('BrowserHistory', () => {
    let bHistory: BrowserHistory;

    beforeEach(() => {
        bHistory = new BrowserHistory();
    });

    test('访问 URL 应该更新当前 URL', () => {
        bHistory.visit("https://www.google.com");
        expect(bHistory.currentUrl()).toBe("https://www.google.com");

        bHistory.visit("https://www.facebook.com");
        expect(bHistory.currentUrl()).toBe("https://www.facebook.com");
    });

    test('后退功能应返回上一个 URL', () => {
        bHistory.visit("https://www.google.com");
        bHistory.visit("https://www.facebook.com");

        expect(bHistory.back()).toBe("https://www.google.com");
        expect(bHistory.currentUrl()).toBe("https://www.google.com");
    });

    test('后退到无前一个 URL 应返回提示信息', () => {
        expect(bHistory.back()).toBe("没有之前的 URL");
    });

    test('前进功能应返回下一个 URL', () => {
        bHistory.visit("https://www.google.com");
        bHistory.visit("https://www.facebook.com");
        bHistory.back(); // 现在在 Google

        expect(bHistory.forward()).toBe("https://www.facebook.com");
        expect(bHistory.currentUrl()).toBe("https://www.facebook.com");
    });

    test('前进到无下一个 URL 应返回提示信息', () => {
        bHistory.visit("https://www.google.com");
        bHistory.visit("https://www.facebook.com");

        expect(bHistory.forward()).toBe("没有下一个 URL");
    });

    test('没有当前 URL 应返回提示信息', () => {
        expect(bHistory.currentUrl()).toBe("没有当前 URL");
    });
});
```

## 总结

栈是一种遵循“后进先出”（LIFO）原则的线性数据结构，广泛应用于各种计算任务。通过实现栈的基本操作，如入栈、出栈和查看栈顶元素，可以有效管理数据的存取顺序。**使用数组实现栈时，采用固定大小的数组，具备快速访问的优点，但限制了栈的大小；而链表实现则提供了动态扩展的灵活性，但在存储和访问上稍显复杂。**

最后有以浏览器的前进和后退功能的例子以辅助理解栈。