## 如何组织一个清晰的项目结构

怎么样才能算一个好的项目结构呢？我想我们可以从文件的增删改查四个维度来分析。

- 增：创建文件时不会纠结，一个文件只应该放到某个特定目录下，不存在二义性
- 删：可以轻松删除一个功能模块，不会和其他模块有过多耦合
- 改/查：可以快速定位到文件，查找文件应该像访问一个**哈希表**，可以直接定位到，而不是像访问一个链表或者拓扑图，需要反复遍历

项目结构划分的底层思想：

### MECE（相互独立、完全穷尽）

MECE是Mutually Exclusive, Collectively Exhaustive的缩写，翻译过来就是"相互独立，完全穷尽"，是《金字塔原理》一书中提到的一种思维方式，目的是让我们思考问题可以更全面，更系统，做到既不重复又不遗漏。

- 相互独立：所谓"相互独立"就是当我们对问题进行分解的时候，确保每个层级的问题与问题之间没有重复、交叉或相关性。
- 完全穷尽：所谓"完全穷尽"则是要求所有的子问题或分类加起来必须覆盖整个问题的所有集合。这意味着在拆解问题时，不能遗漏任何重要的元素或方面。每个与问题相关的点都应该被纳入某个子问题中，以确保对问题的全面分析。
    - 二分法：找一个角度将事物一分为二，非此即彼。
    - 要素法：根据事物的属性进行划分。
    - 流程分析法：按照事物发展的流程或顺序进行分解。
    - 矩阵分析法：将问题划分为不同的象限或区域，每个区域代表一个独立的子问题。

### 分层思维

以组件为例，可分为：

- 通用组件（与业务无关）。
- 项目基础组件（不局限于具体业务，比如基于通用组件封装的自己项目的弹窗、表单、表格等）。
- 业务组件（具体的业务组件，比如：AddUserDialog）。
- 页面组件（与路由一一对应）。

高层组件可以调用底层组件，底层组件绝对不允许引用高层组件。也就是说页面组件可以引用业务组件和项目基础组件，但是项目基础组件中绝对不可以调用业务组件和页面组件

### 领域驱动设计（DDD）

[文章](https://juejin.cn/book/7351005935306801188/section/7351005935348744211#heading-1)原文:

> 领域驱动设计（DDD，Domain-Driven Design），简称 DDD，就是以一种领域专家、设计人员、开发人员都能理解的通用语言作为相互交流的工具，在交流的过程中发现领域概念，然后将这些概念设计成一个领域模型；由领域模型驱动软件设计，用代码来实现该领域模型。
>
> 怎么理解呢，比如你要做一个电商的商品模块，如果你直接给非技术人员（如销售、库管、运营、产品等）看你的代码，他们肯定看不懂的，但是你如果给他们看一个模型，告诉他们你要设计的商品模块包含哪些属性，有哪些功能，他们是可以理解并且帮你去完善的。具体到代码实现上，可以简单理解为在应用层之下再抽象一个领域层，比如公司要开发了多个电商系统，而每个电商系统肯定都会有诸如用户、商品、订单、支付、日志等多个基础模块，不管哪个电商系统，用户、商品等一般底层逻辑都差不太多，如果我们抽象出一个比较好的领域层，那么后续再开始新的电商系统，就基于我们的领域层再开发一个新的业务层即可。

将整个项目分层了三大层：

- 基础层
- 领域层
- 应用层

每一层都有明确的职责和边界，其中基础层主要是存放一些业务无关的基础组件和 utils 库等，领域层存放和业务模型息息相关的所有设计资源，应用层存放项目相关的资源（路由、store、页面等）。

### 就近原则

就近原则是指将逻辑上相近的资源放在一起。这里的“逻辑相近”可以理解为如果 A 和 B 两个文件因同一原因需要同时修改，那么它们应该被放在距离较近的位置。

这样做的好处就是：

- 如果新增模块时，不需要各目录之间反复横跳。
- 修改时能够快速定位。
- 删除一个模块时，简单、快捷、方便的处理。

### 一致原则

一致原则要求在项目中保持相似的结构和命名约定，以便团队（新）成员快速理解项目。一致性有助于降低学习成本、提高团队协作效率，并减少出错的可能性。主要体现在以下方面：

- 目录/文件命名保持一致。
- 目录下的内容要和目录名称保持一致。
- 命名要和使用方保持一致。例如，用户列表页的 URL 为 `http://127.0.0.1:8080/user-list`，对应的页面组件名称也应保持一致。当页面出现问题时，可以迅速定位到相应的组件。

### 最佳实践

以一个单页面应用为例，来设计一个完整的项目结构：

通过 MECE 原则中的二分法，将项目分为两大部分：

- 开发阶段
    - 数据 mock
    - 编译打包 build
    - 单元测试 test
- 非开发阶段
    - 上线部署文档
    - 帮助文档

```tree
├── dev         //工程代码
│   ├── mock      //mock文件
│   ├── build     //编译配置
│   └── test      //测试文件
├── deployer    //部署文件
│   ├── Dockerfile
│   └── nginx
├── doc         //文档
│   └── help.md
├── domain      //领域层
│   ├── user
│   │   ├── const
│   │   │   ├── api.js
│   │   │   └── status.js
│   │   ├── service.js
│   │   ├── components
│   │   │   ├── AddUser.vue
│   │   │   └── UserAvatar.vue
│   │   ├── config.js
│   │   └── utils.js
│   └── product
│       ├── const
│       ├── components
│       ├── service.js
│       ├── config.js
│       └── utils.js
├── src          //应用层
│   ├── assets       //资源文件
│   ├── layout       //布局文件
│   ├── router       //路由配置
│   ├── store        //共享数据
│   └── pages        //页面组件
│       ├── user-list
│       └── user-detail
└── base        //基础层
    ├── const         //常量配置
    ├── styles        //公共样式
    ├── utils         //公共库
    └── components    //项目基础组件
```

## 优雅的开发表单

表单分为受控和非受控!

### 受控组件

组件的内部状态可以通过修改属性值的方式进行控制，受控组件必须满足以下2个条件：

- 存在一个名为 `value` 的属性
    - 组件的初始值由 `value` 属性值决定
    - `value` 属性值变化后组件的内部状态也必须跟着变化
- 组件对外抛出 `onChange` 事件
    - 组件内部状态变化后，以抛出 `onChange` 事件的方式将表单项的最新值传递给父组件

受控组件必须有 `value` 属性和 `onChange` 事件，且 `value` 变化会导致组件数据更新。这样组件的行为就能够被使用方完全控制，所以称为受控组件。

### 非受控组件

非受控组件，即组件的内部状态由组件自身进行维护，而不是受到外部传递过来的props控制，一般来说，非受控组件应该满足以下2个条件：

- 对外提供一个名为 `defaultValue` 的属性
    - 组件的初始状态由 `defaultValue` 决定
    - 后续组件的状态随着用户交互而进行变化，但不通知父组件
- 对外提供一个可以获取组件内部状态的方法
    - 一般通过ref方式访问组件的内部状态value，如 `$refs.***.value`（不建议直接访问组件内部状态）
    - 建议提供一个 `method` 方法获取内部状态，如getValue()

只要开发表单项组件，就要符合这两种范式的规范要求：

- 受控组件：支持属性value和事件onChange
- 非受控组件：支持属性defaultValue和getValue方法

表单开发中常见的问题及解决方案：

| 问题           | 解决方案                               |
| -------------- | -------------------------------------- |
| 充满细节       | 将表单项提取为组件                     |
| 繁琐的Dom      | 通过配置驱动表单生成，可以使用配置表单 |
| 表单封装不规范 | 遵守受控组件和非受控组件的开发要求     |
| 表单校验不统一 | 提取常用校验规则到常量中               |

针对业务开发中的复杂表单问题，可以利用分治思想，将复杂表单拆分成多个简单小表单，每个小表单遵循受控组件和非受控组件规范，并额外提供一个validate方法。
